<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>X on BioDocker Documentation</title>
    <link>http://biodocker.org/docs/categories/x/</link>
    <description>Recent content in X on BioDocker Documentation</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 07 Jun 2016 13:31:56 +0100</lastBuildDate>
    <atom:link href="http://biodocker.org/docs/categories/x/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>BioDocker best practices</title>
      <link>http://biodocker.org/docs/biodocker-best-practices/</link>
      <pubDate>Tue, 07 Jun 2016 13:31:56 +0100</pubDate>
      
      <guid>http://biodocker.org/docs/biodocker-best-practices/</guid>
      <description>

&lt;h1 id=&#34;best-practices&#34;&gt;Best Practices&lt;/h1&gt;

&lt;h2 id=&#34;language-specific&#34;&gt;Language Specific&lt;/h2&gt;

&lt;h3 id=&#34;python&#34;&gt;Python&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Use requirements.txt instead of listing dependencies&lt;/li&gt;
&lt;li&gt;Define library versions&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;optimization&#34;&gt;Optimization&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Use environment variables to avoid repeating yourself&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This is a trick I picked up from reading the Dockerfile (link) of the &amp;ldquo;official&amp;rdquo; node.js docker image. As an aside, this Dockerfile is great. My only criticism is that it sits on top of a huge buildpack-deps (link) image, with all sorts of things I don&amp;rsquo;t want or need.&lt;/p&gt;

&lt;p&gt;You can define environment variables with ENV and then reference them in subsequent RUN commands. Below, I&amp;rsquo;ve paraphrased an excerpt from the linked Dockerfile:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ENV NODE_VERSION 0.10.32

RUN curl -SLO &amp;quot;http://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.gz&amp;quot; &amp;amp;&amp;amp; \
    tar -xzf &amp;quot;node-v$NODE_VERSION-linux-x64.tar.gz&amp;quot; -C /usr/local --strip-components=1 &amp;amp;&amp;amp; \
    rm &amp;quot;node-v$NODE_VERSION-linux-x64.tar.gz&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Merge RUN commands:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;instead of running:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;RUN acb
RUN cbd
RUN bde
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;run:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;RUN acb &amp;amp;&amp;amp; cbd &amp;amp;&amp;amp; bde
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;RUN acb &amp;amp;&amp;amp; \
    cbd &amp;amp;&amp;amp; \
    bde
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Whenever possible, reuse the same base image and use a LTS (Long Term Support) image preferably (Ubuntu 12.04 or 14.04)&lt;/li&gt;
&lt;li&gt;You can use our biodckr/biodocker image based on ubuntu 14.04 with frequent updates and default folders created&lt;/li&gt;
&lt;li&gt;Use a .dockerignore file: In most cases, it’s best to put each Dockerfile in an empty directory. Then, add to that directory only the files needed for building the Dockerfile. To increase the build’s performance, you can exclude files and directories by adding a .dockerignore file to that directory as well. This file supports exclusion patterns similar to .gitignore files. For information on creating one, see the .dockerignore file.&lt;/li&gt;
&lt;li&gt;Avoid installing unnecessary packages: In order to reduce complexity, dependencies, file sizes, and build times, you should avoid installing extra or unnecessary packages just because they might be “nice to have.” For example, you don’t need to include a text editor in a database image.&lt;/li&gt;
&lt;li&gt;Run only one process per container: In almost all cases, you should only run a single process in a single container. Decoupling applications into multiple containers makes it much easier to scale horizontally and reuse containers. If that service depends on another service, make use of container linking.&lt;/li&gt;
&lt;li&gt;Minimize the number of layers: You need to find the balance between readability (and thus long-term maintainability) of the Dockerfile and minimizing the number of layers it uses. Be strategic and cautious about the number of layers you use.&lt;/li&gt;
&lt;li&gt;Sort multi-line arguments: Whenever possible, ease later changes by sorting multi-line arguments alphanumerically. This will help you avoid duplication of packages and make the list much easier to update. This also makes PRs a lot easier to read and review. Adding a space before a backslash () helps as well.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Here’s an example from the buildpack-deps image:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;RUN apt-get update &amp;amp;&amp;amp; apt-get install -y \
    bzr \
    cvs \
    git \
    mercurial \
    subversion
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Note: Don&amp;rsquo;t install build tools without good reason:
Build tools take up a lot of space, and building from source is often slow. If you&amp;rsquo;re just installing somebody else&amp;rsquo;s software, it&amp;rsquo;s usually not necessary to build from source and it should be avoided. For instance, it is not necessary to install python, gcc, etc. to get the latest version of node.js up and running on a Debian host. There is a binary tarball available on the node.js downloads page. Similarly, redis can be installed through the package manager.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;There are at least a few good reasons to have build tools:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;you need a specific version (e.g. redis is pretty old in the Debian repositories).&lt;/li&gt;
&lt;li&gt;you need to compile with specific options.&lt;/li&gt;
&lt;li&gt;you will need to npm install (or equivalent) some modules which compile to binary.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In the second case, think really hard about whether you should be doing that. In the third case, I suggest installing the build tools in another &amp;ldquo;npm installer&amp;rdquo; image, based on the minimal node.js image.&lt;/p&gt;

&lt;p&gt;Don&amp;rsquo;t leave temporary files lying around&lt;/p&gt;

&lt;p&gt;The following Dockerfile results in an image size of 109 MB:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;FROM debian:wheezy
RUN apt-get update &amp;amp;&amp;amp; apt-get install -y wget
RUN wget http://cachefly.cachefly.net/10mb.test
RUN rm 10mb.test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On the other hand, this seemingly-equivalent Dockerfile results in an image size of 99 MB:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;FROM debian:wheezy
RUN apt-get update &amp;amp;&amp;amp; apt-get install -y wget
RUN wget http://cachefly.cachefly.net/10mb.test &amp;amp;&amp;amp; rm 10mb.test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Thus it seems that if you leave a file on disk between steps in your Dockerfile, the space will not be reclaimed when you delete the file. It is also often possible to avoid a temporary file entirely, just piping output between commands. For instance,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;wget -O - http://nodejs.org/dist/v0.10.32/node-v0.10.32-linux-x64.tar.gz | tar zxf -
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Clean up after the package manager&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If you run apt-get update in setting up your container, it populates /var/lib/apt/lists/ with data that&amp;rsquo;s not needed once the image is finalized. You can safely clear out that directory to save a few megabytes.&lt;/p&gt;

&lt;p&gt;This Dockerfile generates a 99 MB image:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;FROM debian:wheezy
RUN apt-get update &amp;amp;&amp;amp; apt-get install -y wget
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;while this one generates a 90 MB image:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FROM debian:wheezy
RUN apt-get update &amp;amp;&amp;amp; apt-get install -y wget &amp;amp;&amp;amp; apt-get clean &amp;amp;&amp;amp; apt-get purge &amp;amp;&amp;amp; rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/*
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Pin package versions&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;While a docker image is immutable (and that&amp;rsquo;s great), a Dockerfile is not guaranteed to produce the same output when run at different times. The problem, of course, is external state, and we have little control over it. It&amp;rsquo;s best to minimize the impact of external state on your Dockerfile to the extent that it&amp;rsquo;s possible. One simple way to do that is to pin package versions when updating through a package manager. Here&amp;rsquo;s an example of how to do that:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# apt-get update
# apt-cache showpkg redis-server
Package: redis-server
Versions:
2:2.4.14-1
# apt-get install redis-server=2:2.4.14-1
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Map log files outside&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;general&#34;&gt;General&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;ADD vs COPY: Both ADD and COPY adds local files when building a container but ADD does some additional magic like adding remote files and ungzipping and untaring archives. Only use ADD if you understand this difference.&lt;/li&gt;
&lt;li&gt;WORKDIR and ENV: Each command will create a new temporary image and runs in a new shell hence if you do a cd &lt;directory&gt; or export &lt;var&gt;=&lt;value&gt; in your Dockerfile it won&amp;rsquo;t work. Use WORKDIR to set your working directory across multiple commands and ENV to set environment variables.&lt;/li&gt;
&lt;li&gt;CMD and ENTRYPOINT: CMD is the default command to execute when an image is run. The default ENTRYPOINT is /bin/sh -c and CMD is passed into that as an argument. We can override ENTRYPOINT in our Dockerfile and make our container behave like an executable taking command line arguments (with default arguments in CMD in our Dockerfile).&lt;/li&gt;
&lt;li&gt;ADD your code last: ADD invalidates your cache if files have changed. Don&amp;rsquo;t invalidate the cache by adding frequently changing stuff too high up in your Dockerfile. Add your code last, libraries and dependencies first. For node.js apps that means adding your package.json first, running npm install and only then adding your code.&lt;/li&gt;
&lt;li&gt;USER in Dockerfiles: By default docker runs everything as root but you can use USER in Dockerfiles. There&amp;rsquo;s no user namespacing in docker so the container sees the users on the host but only uids hence you need the add the users in the container.&lt;/li&gt;
&lt;li&gt;CMD: The CMD instruction should be used to run the software contained by your image, along with any arguments. CMD should almost always be used in the form of CMD [“executable”, “param1”, “param2”…]. Thus, if the image is for a service (Apache, Rails, etc.), you would run something like CMD [&amp;ldquo;apache2&amp;rdquo;,&amp;ldquo;-DFOREGROUND&amp;rdquo;]. Indeed, this form of the instruction is recommended for any service-based image.&lt;/li&gt;
&lt;li&gt;ENV: In order to make new software easier to run, you can use ENV to update the PATH environment variable for the software your container installs. For example, ENV PATH /usr/local/nginx/bin:$PATH will ensure that CMD [“nginx”] just works. The ENV instruction is also useful for providing required environment variables specific to services you wish to containerize, such as Postgres’s PGDATA.&lt;/li&gt;
&lt;li&gt;USER: If a service can run without privileges, use USER to change to a non-root user. Start by creating the user and group in the Dockerfile with something like&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;RUN groupadd -r postgres &amp;amp;&amp;amp; useradd -r -g postgres postgres.
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Note: Users and groups in an image get a non-deterministic UID/GID in that the “next” UID/GID gets assigned regardless of image rebuilds. So, if it’s critical, you should assign an explicit UID/GID.
You should avoid installing or using sudo since it has unpredictable TTY and signal-forwarding behavior that can cause more problems than it solves. If you absolutely need functionality similar to sudo (e.g., initializing the daemon as root but running it as non-root), you may be able to use “gosu”.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Lastly, to reduce layers and complexity, avoid switching USER back and forth frequently.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;WORKDIR: For clarity and reliability, you should always use absolute paths for your WORKDIR. Also, you should use WORKDIR instead of proliferating instructions like RUN cd … &amp;amp;&amp;amp; do-something, which are hard to read, troubleshoot, and maintain.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;volumes&#34;&gt;Volumes&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Should always map to the same /data and /config folders&lt;/li&gt;
&lt;li&gt;Should be RW (read/write) unless there&amp;rsquo;s a good reason not to&lt;/li&gt;
&lt;li&gt;Config and Log files can be mapped to the host but should preferentially be symbolically linked to the /data or /config folder&lt;/li&gt;
&lt;li&gt;Additional mappings can be created if necessary&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;images&#34;&gt;Images&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Images should be based on the latest LTS image available (Ubuntu 12.04 and 14.04) or to one of our images&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;sources-and-useful-links&#34;&gt;Sources and Useful Links&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/veggiemonk/awesome-docker#optimizing-images&#34;&gt;https://github.com/veggiemonk/awesome-docker#optimizing-images&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://labs.ctl.io/optimizing-docker-images/?hvid=1OW0br&#34;&gt;https://labs.ctl.io/optimizing-docker-images/?hvid=1OW0br&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.docker.com/articles/dockerfile_best-practices/&#34;&gt;https://docs.docker.com/articles/dockerfile_best-practices/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://csaba.palfi.me/random-docker-tips/&#34;&gt;http://csaba.palfi.me/random-docker-tips/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.docker.com/articles/dockerfile_best-practices/&#34;&gt;https://docs.docker.com/articles/dockerfile_best-practices/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://jonathan.bergknoff.com/journal/building-good-docker-images&#34;&gt;http://jonathan.bergknoff.com/journal/building-good-docker-images&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Deploying a new Project</title>
      <link>http://biodocker.org/docs/biodocker-deploy-new/</link>
      <pubDate>Tue, 07 Jun 2016 12:06:21 +0100</pubDate>
      
      <guid>http://biodocker.org/docs/biodocker-deploy-new/</guid>
      <description>&lt;p&gt;In order to deploy a new Docker project with your software you must follow this steps:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Clone our &lt;a href=&#34;https://github.com/BioDocker/sandbox&#34;&gt;Sandbox&lt;/a&gt; repository&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Create a folder to your program with the necessary files following our &lt;a href=&#34;https://github.com/BioDocker/specifications/wiki/Project-organization&#34;&gt;guidelines&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/BioDocker/specifications/wiki/Dockerfile-template&#34;&gt;Create a Dockerfile&lt;/a&gt; following the general guidelines.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Build the container in your own computer and test the image. If it works properly, then you may follow.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Push the container to your fork of our Sandbox and create an pull request following our contribution guidelines:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/BioDocker/biodocker/blob/master/CONTRIBUTING.md&#34;&gt;https://github.com/BioDocker/biodocker/blob/master/CONTRIBUTING.md&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If you can&amp;rsquo;t do that, send a message to the &lt;a href=&#34;mailto:biodockers@gmail.com&#34;&gt;biodockers@gmail.com&lt;/a&gt; so that we can help you adding your program.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Upon acceptance, we will create an &lt;a href=&#34;https://docs.docker.com/docker-hub/builds/&#34;&gt;automatic build&lt;/a&gt; on DockerHub (this will allow people to search for the container using docker search).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Spread the news!&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Using input  and Output files</title>
      <link>http://biodocker.org/docs/biodocker-input-output/</link>
      <pubDate>Tue, 07 Jun 2016 11:56:34 +0100</pubDate>
      
      <guid>http://biodocker.org/docs/biodocker-input-output/</guid>
      <description>

&lt;h1 id=&#34;using-input-and-output-files&#34;&gt;Using input  and Output files&lt;/h1&gt;

&lt;p&gt;In many cases the software you are using requires an input or an output file to work.
This can be achieved using a container image, but it requires that you change the way how you execute
the docker daemon.&lt;/p&gt;

&lt;p&gt;The first step is to have a specific folder in your computer to serve as a shared folder between your system and the container. In this case let&amp;rsquo;s place a file called prot.fa inside a folder called /home/user/docker/.&lt;/p&gt;

&lt;p&gt;The /home/user/docker/ folder will be mapped inside the container, that way this can server as a gateway for files, both the input and the output files will be placed there.&lt;/p&gt;

&lt;p&gt;After setting the folder and necessary files inside we can execute the image we want. In the example bellow we are running an image built from an example container:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$docker run -v /home/user/docker/:/data/ biodckr/program -input /data/prot.fa -output /data/result.txt`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our local path /home/user/docker/ will map inside the container into a folder called /data/ and the software will have access to the file. After the processing is done the result file will be saved on the same place and we can have it outside the container in the same folder.
In this scenario, the only difference is the use of the parameter &lt;code&gt;-v&lt;/code&gt; when running the image, this parameter tells the docker daemon that when are mapping something from the host system internally.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Biodocker dockerfile template</title>
      <link>http://biodocker.org/docs/biodocker-docker-template/</link>
      <pubDate>Tue, 07 Jun 2016 11:37:37 +0100</pubDate>
      
      <guid>http://biodocker.org/docs/biodocker-docker-template/</guid>
      <description>

&lt;h1 id=&#34;biodocker-dockerfile-template&#34;&gt;Biodocker dockerfile template&lt;/h1&gt;

&lt;p&gt;This is a standard template for creating a new Dockerfile for BioDocker:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Note: Please always follow the &lt;a href=&#34;../../biodocker-best-practices/&#34;&gt;best practices&lt;/a&gt; and help pages &lt;a href=&#34;../../biodocker-input-output/&#34;&gt;Using input and Output files&lt;/a&gt; information.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Bellow is the complete example of a BioDocker Dockerfile:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#################################################################
# Dockerfile
#
# Version:          1
# Software:         Comet
# Software Version: 2015020
# Description:      basic local alignment search tool
# Website:          http://comet-ms.sourceforge.net/
# Tags:             Proteomics
# Provides:         Comet 2015020
# Base Image:       biodckr/biodocker
# Build Cmd:        docker build --rm -t biodckrdev/comet 2015020/.
# Pull Cmd:         docker pull biodckr/comet
# Run Cmd:          docker run --rm -it biodckrdev/comet &amp;lt;options&amp;gt; &amp;lt;files&amp;gt;
# Extra:            Extra information
# Extra:            with new lines if necessary
#################################################################

# Set the base image to biodocker base image
FROM biodckr/biodocker

################## BEGIN INSTALLATION ######################

# Change user to root
USER root

# UPDATE APT, INSTALL PREREQUISITES AND CLEAN CACHE
RUN apt-get clean all &amp;amp;&amp;amp; \
    apt-get update -y &amp;amp;&amp;amp; \
    apt-get upgrade -y &amp;amp;&amp;amp; \
    apt-get install -y wget &amp;amp;&amp;amp; \
    apt-get clean &amp;amp;&amp;amp; \
    apt-get purge &amp;amp;&amp;amp; \
    rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/*

# ADD FILES
ADD comet.2015020.linux.exe /home/biodocker/bin/

# RUN COMMANDS
RUN chmod +x /home/biodocker/bin/comet.2015020.linux.exe

# CHANGE USER BACK TO BIODOCKER
USER biodocker

# CHANGE WORKDIR TO /DATA
WORKDIR /data

# DEFINE DEFAULT COMMAND
CMD [&amp;quot;comet.2015020.linux.exe&amp;quot;]

##################### INSTALLATION END #####################

# File Author / Maintainer
MAINTAINER Felipe da Veiga Leprevost &amp;lt;felipe@leprevost.com.br&amp;gt;
# Modified by Yasset Perez-Riverol. 7edf3b0
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;header&#34;&gt;Header&lt;/h2&gt;

&lt;p&gt;Every Dockerfile must have a header with the following items:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Dockerfile Version&lt;/strong&gt;: This is a single-number version system (ex: v1, v2, v3 &amp;hellip;). Every change in the file must increase the version number in 1.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Software&lt;/strong&gt;: The name of the software installed inside the container. This can be a little tricky because some software demand libraries or dependencies. In this case the idea is to describe the &amp;ldquo;principal&amp;rdquo; software of the container, or the reason for built it.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Software Version&lt;/strong&gt;: The version of the software installed.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Description&lt;/strong&gt;:      Single line description of the tool&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Website&lt;/strong&gt;:          URL(s) for the program developer separated by vertical bars (|)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Tags&lt;/strong&gt;: Program tags separated by vertical bars (|)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Genomics&lt;/li&gt;
&lt;li&gt;Protemomics&lt;/li&gt;
&lt;li&gt;Transcriptomics&lt;/li&gt;
&lt;li&gt;Metabolomics&lt;/li&gt;
&lt;li&gt;General&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Provides&lt;/strong&gt;: List of programs provided separated by vertical bars (|)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Base Image: All containers are based on a specific GNU/Linux system. There is no preference for a specific OS flavor but, to reduce disk usage, we recommend to use our own biodkr/biodocker image.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Docker commands: Commands used to build, pull and run the docker image&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Extra: Extra information. this tag can appear multiple times&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;image-setting-from&#34;&gt;Image Setting - FROM&lt;/h2&gt;

&lt;p&gt;The next element is the base image and any configuration to the system you are installing:&lt;/p&gt;

&lt;p&gt;In the example above the Base Image is defined as biodckr/biodocker which is based on ubuntu latest LTS (Long Term Support) release and kept up to date with updates.&lt;/p&gt;

&lt;h2 id=&#34;installation-run&#34;&gt;Installation - RUN&lt;/h2&gt;

&lt;p&gt;The installation area is where you instructions to build the software will be defined. Here is the correct place to put Dockerfile syntax and system commands.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;################### BEGIN INSTALLATION ########################

# Change user to root
USER root

# UPDATE APT, INSTALL PREREQUISITES AND CLEAN CACHE
RUN apt-get clean all &amp;amp;&amp;amp; \
    apt-get update -y &amp;amp;&amp;amp; \
    apt-get upgrade -y &amp;amp;&amp;amp; \
    apt-get install -y wget &amp;amp;&amp;amp; \
    apt-get clean &amp;amp;&amp;amp; \
    apt-get purge &amp;amp;&amp;amp; \
    rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/*

# ADD FILES
ADD comet.2015020.linux.exe /home/biodocker/bin/

# RUN COMMANDS
RUN chmod +x /home/biodocker/bin/comet.2015020.linux.exe

# Change user to back to biodocker
USER biodocker

# CHANGE WORKDIR TO /DATA
WORKDIR /data

# DEFINE DEFAULT COMMAND
CMD [&amp;quot;comet.2015020.linux.exe&amp;quot;]

#################### END INSTALLATION #########################
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Commands should be merged with &amp;lsquo;&amp;amp;&amp;amp; \&amp;rsquo; whenever possible in order to create fewer intermediate images.&lt;/li&gt;
&lt;li&gt;A biodocker user has been created (id 1001) so that applications are not run as root.&lt;/li&gt;
&lt;li&gt;If possible, add the program to /usr/bin, otherwise, add to /home/biodocker/bin&lt;/li&gt;
&lt;li&gt;return to the regular USER&lt;/li&gt;
&lt;li&gt;change the WORKDIR to the data folder&lt;/li&gt;
&lt;li&gt;set the VOLUMEs to be exported (/data and /config are exported by default by the base image)&lt;/li&gt;
&lt;li&gt;EXPOSE ports (if necessary)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;signature-maintainer&#34;&gt;Signature - MAINTAINER&lt;/h2&gt;

&lt;p&gt;The File Author/ Maintainer signature. By default the Dockerfile only accepts one MAINTAINER tag. This will be the place the original author name. After updates are added to the file, the contributors name should appear in commented lines.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# File Author / Maintainer
MAINTAINER Felipe da Veiga Leprevost &amp;lt;felipe@leprevost.com.br&amp;gt;
# Modified by Yasset Perez-Riverol. 7edf3b0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The number after Yasset name is the 7 first digits of the commit.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Biodocker Registry</title>
      <link>http://biodocker.org/docs/biodocker-registry/</link>
      <pubDate>Tue, 07 Jun 2016 08:48:27 +0100</pubDate>
      
      <guid>http://biodocker.org/docs/biodocker-registry/</guid>
      <description>

&lt;h1 id=&#34;biodocker-registry&#34;&gt;BioDocker Registry&lt;/h1&gt;
</description>
    </item>
    
    <item>
      <title>Users Quick Start</title>
      <link>http://biodocker.org/docs/quick-start-users/</link>
      <pubDate>Tue, 07 Jun 2016 08:45:26 +0100</pubDate>
      
      <guid>http://biodocker.org/docs/quick-start-users/</guid>
      <description>

&lt;h1 id=&#34;quick-start-for-users&#34;&gt;Quick Start for Users&lt;/h1&gt;

&lt;h2 id=&#34;so-what-s-this-biodocker-thing-all-about&#34;&gt;So what’s this BioDocker thing all about?&lt;/h2&gt;

&lt;p&gt;Docker allows you to run applications, worlds you create, inside containers.
Running an application inside a container takes a single command:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker run.
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Note: Depending on your Docker system configuration, you may be required to preface each docker command on this page with sudo.
To avoid this behavior, your system administrator can create a Unix group called docker and add users to it.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;run-a-comet-search-engine&#34;&gt;Run a Comet search engine&lt;/h2&gt;

&lt;p&gt;Let’s run a a proteomics search engine to identified proteins using &lt;a href=&#34;http://comet-ms.sourceforge.net/&#34;&gt;Comet&lt;/a&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Proteomics data analysis is dominated by database-based search engines strategies.
Amount Search Engines, Comet is one of the most popular nowadays.
We are going to show how to run a simple analysis protocol using the &lt;a href=&#34;https://github.com/BioDocker/containers/tree/master/Comet&#34;&gt;BioDocker Comet&lt;/a&gt; database
search engine.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;get-the-docker-container&#34;&gt;Get the docker container&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ docker pull biodckr/comet
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Some insides into this commandline:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The &lt;a href=&#34;../../biodocker-registry/&#34;&gt;biodocker registry&lt;/a&gt; &lt;strong&gt;biodckr&lt;/strong&gt; contains all the BioDocker deployed containers ready to be use.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;docker pull&lt;/strong&gt; donwload the latest container of Comet&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;If the user wants to download an specific version of the comet biodcoker container it can be done by providing the current corrsponding tag.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ docker pull biodckr/comet --tag=&amp;quot;2016012&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;run-the-docker-container&#34;&gt;Run the Docker Container&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: First thing to do is to arrange the necessary &lt;a href=&#34;../../biodocker-input-output/&#34;&gt;files to run your data&lt;/a&gt;.
For this pipeline we are going to need converted raw files from some mass spectrometry analysis and a protein
database in FASTA format. This are the files we are using for this tutorial:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;[b1930_293T_proteinID_10A_QE3_122212.mzXML]()&lt;/li&gt;
&lt;li&gt;[b1931_293T_proteinID_11A_QE3_122212.mzXML]()&lt;/li&gt;
&lt;li&gt;[database.fa]()&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;I&amp;rsquo;m placing all these files inside a folder called /home/user/workspace/&lt;/p&gt;

&lt;h3 id=&#34;print-comet-a-new-parameter-file&#34;&gt;Print Comet a new parameter file:&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ docker run -v /home/user/workspace/:/data/ biodckr/comet comet -p
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Some notes about this commandline:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;To have access to files inside the container, and vice-versa, we need to map a local folder inside the container,
that way all files inside this mapped folder will be visible and accessible to us and to the container.&lt;/li&gt;
&lt;li&gt;This is possible using the &lt;strong&gt;parameter -v&lt;/strong&gt; and passing the complete path from our folder that we wish to map inside the container. In this case we are mapping /home/user/workspace into /data/, a pre-existent folder inside the container.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;biodckr/comet&lt;/strong&gt; is the name of the container we pulled from BioDocker.&lt;/li&gt;
&lt;li&gt;The &lt;strong&gt;comet&lt;/strong&gt; right after is the name of the program inside the container we are running.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;After running this command you will see a new file in the folder called comet.params.new,
let&amp;rsquo;s rename it to comet.params and edit some of the options.
In this case I will just change two parameters:
database_name = /data/database.fa
decoy_search = 1&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: Remember that the files inside the container are actually inside a folder called /data/,
so that&amp;rsquo;s how we are going to pass the file location to the programs.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;start-the-database-search&#34;&gt;Start the database search:&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;    $ docker run -v /home/felipe/workspace/:/data/ biodckr/comet comet -Pcomet.params b1930_293T_proteinID_10A_QE3_122212.mzXML b1931_293T_proteinID_11A_QE3_122212.mzXML
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If everything went well you should see two new files on your folder; b1930_293T_proteinID_10A_QE3_122212.pep.xml and b1931_293T_proteinID_11A_QE3_122212.pep.xml&lt;/p&gt;

&lt;h2 id=&#34;other-interesting-options&#34;&gt;Other interesting options&lt;/h2&gt;

&lt;p&gt;Simple bash interactive script:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ docker run -t -i ubuntu /bin/bash
root@af8bae53bdd3:/#
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this example:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;docker run runs a container.&lt;/li&gt;
&lt;li&gt;ubuntu is the image you would like to run.&lt;/li&gt;
&lt;li&gt;-t flag assigns a pseudo-tty or terminal inside the new container.&lt;/li&gt;
&lt;li&gt;-i flag allows you to make an interactive connection by grabbing the standard in (STDIN) of the container.&lt;/li&gt;
&lt;li&gt;/bin/bash launches a Bash shell inside our container.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The container launches. We can see there is a command prompt inside it:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;root@af8bae53bdd3:/#
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let’s try running some commands inside the container:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;root@af8bae53bdd3:/# ls
bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this example:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;ls displays the directory listing of the root directory of a typical Linux file system.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Now, you can play around inside this container. When completed, run the exit command or enter Ctrl-D to exit the interactive shell.&lt;/p&gt;

&lt;p&gt;root@af8bae53bdd3:/# exit&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Note: As with our previous container, once the Bash shell process has finished, the container stops.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;start-a-daemonized-hello-world&#34;&gt;Start a daemonized Hello world&lt;/h3&gt;

&lt;p&gt;Let’s create a container that runs as a daemon.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ docker run -d ubuntu /bin/sh -c &amp;quot;while true; do echo hello world; sleep 1; done&amp;quot;
1e5535038e285177d5214659a068137486f96ee5c2e85a4ac52dc83f2ebe4147
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this example:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;docker run runs the container.&lt;/li&gt;
&lt;li&gt;-d flag runs the container in the background (to daemonize it).&lt;/li&gt;
&lt;li&gt;ubuntu is the image you would like to run.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Finally, we specify a command to run: &lt;strong&gt;/bin/sh -c &amp;ldquo;while true; do echo hello world; sleep 1; done&amp;rdquo;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;In the output, we do not see hello world but a long string:&lt;/p&gt;

&lt;p&gt;1e5535038e285177d5214659a068137486f96ee5c2e85a4ac52dc83f2ebe4147&lt;/p&gt;

&lt;p&gt;This long string is called a container ID. It uniquely identifies a container so we can work with it.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Note: The container ID is a bit long and unwieldy. Later, we will cover the short ID and ways to name our containers to make working with them easier.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We can use this container ID to see what’s happening with our hello world daemon.&lt;/p&gt;

&lt;p&gt;First, let’s make sure our container is running. Run the &lt;strong&gt;docker ps&lt;/strong&gt; command. The docker ps command queries the Docker daemon for information about all the containers it knows about.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ docker ps
CONTAINER ID  IMAGE         COMMAND               CREATED        STATUS       PORTS NAMES
1e5535038e28  ubuntu  /bin/sh -c &#39;while tr  2 minutes ago  Up 1 minute        insane_babbage
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this example, we can see our daemonized container. The docker ps returns some useful information:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;1e5535038e28 is the shorter variant of the container ID.&lt;/li&gt;
&lt;li&gt;ubuntu is the used image.&lt;/li&gt;
&lt;li&gt;the command, status, and assigned name insane_babbage.&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;Note: Docker automatically generates names for any containers started. We’ll see how to specify your own names a bit later.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Now, we know the container is running. But is it doing what we asked it to do? To see this we’re going to look inside the container using the docker logs command.&lt;/p&gt;

&lt;p&gt;Let’s use the container name insane_babbage.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ docker logs insane_babbage
hello world
hello world
hello world
. . .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this example:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;docker logs looks inside the container and returns hello world.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;command-resume&#34;&gt;Command Resume&lt;/h2&gt;

&lt;p&gt;So far, you launched your first containers using the docker run command. You ran an interactive container that ran in the foreground. You also ran a detached container that ran in the background. In the process you learned about several Docker commands:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;docker run&lt;/strong&gt;  - Run a docker container&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;dcoker pull&lt;/strong&gt; - Download the container from Biodocker Hub&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;docker ps&lt;/strong&gt;   - Lists containers.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;docker logs&lt;/strong&gt; - Shows us the standard output of a container.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;docker stop&lt;/strong&gt; - Stops running containers.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Now, you have the basis learn more about Docker &lt;a href=&#34;https://docs.docker.com/engine/userguide/containers/usingdocker/&#34;&gt;Go to “Run a simple application“&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Learn about Docker Client</title>
      <link>http://biodocker.org/docs/docker-client/</link>
      <pubDate>Mon, 06 Jun 2016 20:58:39 +0100</pubDate>
      
      <guid>http://biodocker.org/docs/docker-client/</guid>
      <description>

&lt;h1 id=&#34;learn-about-the-docker-client&#34;&gt;Learn about the Docker client&lt;/h1&gt;

&lt;p&gt;If you didn’t realize it yet, you’ve been using the Docker client each time you typed docker in your &lt;strong&gt;Bash terminal&lt;/strong&gt;.
The client is a simple command line client also known as a command-line interface (CLI). Each action you can take with the
client is a command and each command can take a series of flags and arguments.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Usage:  [sudo] docker [subcommand] [flags] [arguments] ..
# Example:
$ docker run -i -t ubuntu /bin/bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can see this in action by using the docker version command to return version information on the currently installed Docker client and daemon.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ docker version
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This command will not only provide you the version of Docker client and daemon you are using, but also the version of Go (the programming language powering Docker).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;  Client:
  Version:      1.8.1
  API version:  1.20
  Go version:   go1.4.2
  Git commit:   d12ea79
  Built:        Thu Aug 13 02:35:49 UTC 2015
  OS/Arch:      linux/amd64

Server:
  Version:      1.8.1
  API version:  1.20
  Go version:   go1.4.2
  Git commit:   d12ea79
  Built:        Thu Aug 13 02:35:49 UTC 2015
  OS/Arch:      linux/amd64
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;get-docker-command-help&#34;&gt;Get Docker command help&lt;/h2&gt;

&lt;p&gt;You can display the help for specific Docker commands. The help details the options and their usage.
To see a list of all the possible commands, use the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ docker --help
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To see usage for a specific command, specify the command with the --help flag:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ docker attach --help

Usage: docker attach [OPTIONS] CONTAINER

Attach to a running container

  --help              Print usage
  --no-stdin          Do not attach stdin
  --sig-proxy=true    Proxy all received signals to the process
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Note: For further details and examples of each command, see the command reference in this guide.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Docker in NutShell</title>
      <link>http://biodocker.org/docs/docker-in-nutshell/</link>
      <pubDate>Mon, 06 Jun 2016 08:47:25 +0100</pubDate>
      
      <guid>http://biodocker.org/docs/docker-in-nutshell/</guid>
      <description>

&lt;h1 id=&#34;docker-in-nutshell&#34;&gt;Docker in NutShell&lt;/h1&gt;

&lt;p&gt;Docker is an open platform for developing, shipping, and running applications.
Docker is designed to deliver your applications faster. With Docker you can separate your applications from your
infrastructure.&lt;/p&gt;

&lt;p&gt;Docker does this by combining kernel containerization features with workflows and tooling that help you manage
and deploy your applications. At its core, Docker provides a way to run almost any application securely isolated
in a container. The isolation and security allow you to run many containers simultaneously on your host.&lt;/p&gt;

&lt;p&gt;Docker’s container-based platform allows for highly portable workloads. Docker containers can run on a developer’s
local host, on physical or virtual machines in a data center, or in the Cloud.&lt;/p&gt;

&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/aLipr7tTuA4&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;

&lt;h2 id=&#34;what-are-the-major-docker-components&#34;&gt;What are the major Docker components?&lt;/h2&gt;

&lt;p&gt;Docker has two major components:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.docker.com/engine/quickstart/&#34;&gt;Docker Engine&lt;/a&gt;: the open source containerization platform.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://hub.docker.com&#34;&gt;Docker Hub&lt;/a&gt;: our Software-as-a-Service platform for sharing and managing Docker containers.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;what-is-docker-s-architecture&#34;&gt;What is Docker’s architecture?&lt;/h2&gt;

&lt;p&gt;Docker uses a client-server architecture. The Docker client talks to the Docker daemon, which does the heavy lifting of building,
running, and distributing your Docker containers. Both the Docker client and the daemon can run on the same system, or you can connect a Docker client to a remote Docker daemon.&lt;/p&gt;

&lt;h2 id=&#34;docker-architecture-diagram&#34;&gt;Docker Architecture Diagram&lt;/h2&gt;

&lt;p&gt;&lt;p style=&#34;text-align: center&#34;&gt;
        &lt;img alt=&#34;Layered Filesystems Diagram&#34; src=&#34;../../icons/figure2.svg&#34;&gt;
   &lt;/p&gt;
    &lt;p&gt;
       &lt;ul&gt;
        &lt;li&gt;The Docker daemon: As shown in the diagram above, the Docker daemon runs on a host machine.
            The user does not directly interact with the daemon, but instead through the Docker client.
        &lt;/li&gt;
        &lt;li&gt;The Docker client: The Docker client, in the form of the docker binary, is the primary user interface to Docker.
            It accepts commands from the user and communicates back and forth with a Docker daemon.
        &lt;/li&gt;
        &lt;li&gt;Inside Docker: To understand Docker’s internals, you need to know about three resources:
            &lt;ul&gt;
             &lt;li&gt;&lt;a href=&#34;https://docs.docker.com/v1.8/userguide/dockerimages/&#34;&gt;Docker images&lt;/a&gt;:A Docker image is a read-only template. For example,
                 an image could contain an Ubuntu operating system with Apache and your web application installed.
                 Images are used to create Docker containers.
              &lt;/li&gt;&lt;br /&gt;
              &lt;li&gt;Docker registries: Docker registries hold images. These are public or private stores from
                  which you upload or download images. The public Docker registry is provided with the Docker Hub.
              &lt;/li&gt;
              &lt;li&gt;&lt;a href=&#34;https://docs.docker.com/engine/userguide/storagedriver/imagesandcontainers/&#34;&gt;Docker containers&lt;/a&gt;: Docker containers are similar to a directory. A Docker container holds everything that
                  is needed for an application to run. Each container is created from a Docker image. Docker containers can
                  be run, started, stopped, moved, and deleted.
              &lt;/li&gt;
            &lt;/ul&gt;
        &lt;/li&gt;&lt;br /&gt;
       &lt;/ul&gt;
     &lt;/p&gt;&lt;/p&gt;

&lt;h3 id=&#34;how-does-a-docker-image-work&#34;&gt;How does a Docker image work?&lt;/h3&gt;

&lt;p&gt;We’ve already seen that Docker images are read-only templates from which Docker containers are launched.
Each image consists of a series of layers. Docker makes use of union file systems to combine these layers into a single image.
Union file systems allow files and directories of separate file systems, known as branches, to be transparently overlaid,
forming a single coherent file system.&lt;/p&gt;

&lt;p&gt;One of the reasons Docker is so lightweight is because of these layers. When you change a Docker image—for example,
update an application to a new version— a new layer gets built. Thus, rather than replacing the whole image or entirely rebuilding,
as you may do with a virtual machine, only that layer is added or updated. Now you don’t need to distribute a whole new image,
just the update, making distributing Docker images faster and simpler.&lt;/p&gt;

&lt;p&gt;Every image starts from a &lt;strong&gt;Base image&lt;/strong&gt;, for example ubuntu, a base Ubuntu image, or fedora, a base Fedora image.
You can also use images of your own as the basis for a new image.&lt;/p&gt;

&lt;p&gt;Docker images are then built from these base images using a simple, descriptive set of steps we call instructions.
Each instruction creates a new layer in our image. Instructions include actions like:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Run a command&lt;/li&gt;
&lt;li&gt;Add a file or directory&lt;/li&gt;
&lt;li&gt;Create an environment variable&lt;/li&gt;
&lt;li&gt;What process to run when launching a container from this image&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;These instructions are stored in a file called a Dockerfile. A &lt;strong&gt;Dockerfile&lt;/strong&gt; is a text based script that contains instructions and commands for building the image from the base image. Docker reads this Dockerfile when you request a build of an image, executes the instructions, and returns a final image.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
FROM biodckr/biodocker:latest

################## BEGIN INSTALLATION ###########################

USER biodocker

RUN ZIP=comet_binaries_2016012.zip &amp;amp;&amp;amp; \ wget https://github.com/BioDocker/software-archive/releases/download/Comet/$ZIP -O /tmp/$ZIP &amp;amp;&amp;amp; \ unzip /tmp/$ZIP -d /home/biodocker/bin/Comet/ &amp;amp;&amp;amp; \ chmod -R 755 /home/biodocker/bin/Comet/* &amp;amp;&amp;amp; \ rm /tmp/$ZIP
RUN mv /home/biodocker/bin/Comet/comet.2016012.linux.exe /home/biodocker/bin/Comet/comet
ENV PATH /home/biodocker/bin/Comet:$PATH

WORKDIR /data/

##################### INSTALLATION END ##########################

MAINTAINER Felipe da Veiga Leprevost &amp;lt;felipe@leprevost.com.br&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;how-does-a-container-work&#34;&gt;How does a container work?&lt;/h3&gt;

&lt;p&gt;A container consists of an operating system, user-added files, and meta-data. As we’ve seen, each container is built from an image.
That image tells Docker what the container holds, what process to run when the container is launched, and a variety of other
configuration data. The Docker image is read-only.&lt;/p&gt;

&lt;p&gt;When Docker runs a container from an image, it adds a read-write layer on top of the image
(using a union file system as we saw earlier) in which your application can then run.&lt;/p&gt;

&lt;p&gt;When you run a container, either by using the docker binary or via the API, the Docker client tells
the Docker daemon to run a container.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ docker run -i -t ubuntu /bin/bash
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;The Docker Engine client is launched using the docker binary with the run option running a new container. The bare minimum the
Docker client needs to tell the Docker daemon to run the container is:&lt;/p&gt;

&lt;p&gt;What Docker image to build the container from, for example: &lt;strong&gt;ubuntu&lt;/strong&gt;
The command you want to run inside the container when it is launched, for example: &lt;strong&gt;/bin/bash&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;references&#34;&gt;References:&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.docker.com/engine/understanding-docker/&#34;&gt;Understand Docker Architecture&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=pGYAg7TMmp0&#34;&gt;Docker Tutorial - What is Docker &amp;amp; Docker Containers, Images, etc?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.digitalocean.com/community/tutorials/the-docker-ecosystem-an-introduction-to-common-components&#34;&gt;Docker Ecosystem&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>How to Install Docker?</title>
      <link>http://biodocker.org/docs/docker-install/</link>
      <pubDate>Sat, 04 Jun 2016 13:53:55 +0100</pubDate>
      
      <guid>http://biodocker.org/docs/docker-install/</guid>
      <description>

&lt;h1 id=&#34;how-to-install-docker&#34;&gt;How to Install Docker?&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;Note: This release of Docker deprecates the Boot2Docker command line in favor of Docker Machine.
Use the Docker Toolbox to install Docker Machine as well as the other Docker tools.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;mac-os-x-installation&#34;&gt;Mac OS X Installation&lt;/h2&gt;

&lt;p&gt;If you have VirtualBox running, you must shut it down before running the installer.&lt;/p&gt;

&lt;p&gt;1- Go to the &lt;a href=&#34;https://www.docker.com/toolbox&#34;&gt;Docker Toolbox&lt;/a&gt; page.&lt;/p&gt;

&lt;p&gt;2- Click the Download link.&lt;/p&gt;

&lt;p&gt;3- Install Docker Toolbox by double-clicking the package or by right-clicking and choosing “Open” from the pop-up menu.&lt;/p&gt;

&lt;div&gt;
 &lt;p&gt;
  The installer launches the “Install Docker Toolbox” dialog.
  
&lt;figure &gt;
    
        &lt;img src=&#34;../../icons/figure-mac-1.png&#34; alt=&#34;Install Docker Toolbox&#34; /&gt;
    
    
&lt;/figure&gt;

&lt;/p&gt;
&lt;/div&gt;
  

&lt;p&gt;4- Press “Continue” to install the toolbox.&lt;/p&gt;

&lt;p&gt;
The installer presents you with options to customize the standard installation.
 
&lt;figure &gt;
    
        &lt;img src=&#34;../../icons/figure-mac-2.png&#34; /&gt;
    
    
&lt;/figure&gt;

&lt;/p&gt;
  

&lt;p&gt;By default, the standard Docker Toolbox installation:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;installs binaries for the Docker tools in /usr/local/bin&lt;/li&gt;
&lt;li&gt;makes these binaries available to all users&lt;/li&gt;
&lt;li&gt;installs VirtualBox; or updates any existing installation&lt;/li&gt;
&lt;li&gt;To change these defaults, press “Customize” or “Change Install Location.”&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;5- Press “Install” to perform the standard installation.&lt;/p&gt;

&lt;p&gt;
The system prompts you for your password.
 
&lt;figure &gt;
    
        &lt;img src=&#34;../../icons/figure-mac-3.png&#34; /&gt;
    
    
&lt;/figure&gt;

&lt;/p&gt;
  

&lt;p&gt;6- Provide your password to continue with the installation.&lt;/p&gt;

&lt;p&gt;
 
&lt;figure &gt;
    
        &lt;img src=&#34;../../icons/figure-mac-4.png&#34; /&gt;
    
    
&lt;/figure&gt;

&lt;/p&gt;
  

&lt;p&gt;When it completes, the installer provides you with some information you can use to complete some common tasks.&lt;/p&gt;

&lt;h3 id=&#34;references&#34;&gt;References&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.docker.com/engine/installation/mac/&#34;&gt;Installing Docker in Mac&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;windows-installation&#34;&gt;Windows Installation&lt;/h2&gt;

&lt;p&gt;If you have VirtualBox running, you must shut it down before running the installer.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Go to the Docker Toolbox page.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Click the installer link to download.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Install Docker Toolbox by double-clicking the installer.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The installer launches the “Setup - Docker Toolbox” dialog.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;../../icons/figure-win-1.png&#34; alt=&#34;Install Docker Toolbox&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;ol&gt;
&lt;li&gt;Press “Next” to install the toolbox.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The installer presents you with options to customize the standard installation. By default, the standard Docker Toolbox installation:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;installs executables for the Docker tools in C:\Program Files\Docker Toolbox&lt;/li&gt;
&lt;li&gt;install VirtualBox; or updates any existing installation&lt;/li&gt;
&lt;li&gt;adds a Docker Inc. folder to your program shortcuts&lt;/li&gt;
&lt;li&gt;updates your PATH environment variable&lt;/li&gt;
&lt;li&gt;adds desktop icons for the Docker Quickstart Terminal and Kitematic&lt;/li&gt;

&lt;li&gt;&lt;p&gt;This installation assumes the defaults are acceptable.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Press “Next” until you reach the “Ready to Install” page.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The system prompts you for your password.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;../../icons/figure-mac-2.png&#34; alt=&#34;Install&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;ol&gt;
&lt;li&gt;Press “Install” to continue with the installation.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;When it completes, the installer provides you with some information you can use to complete some common tasks.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;../../icons/figure-mac-3.png&#34; alt=&#34;All finished&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;ol&gt;
&lt;li&gt;Press “Finish” to exit.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;references-1&#34;&gt;References&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.docker.com/engine/installation/windows/&#34;&gt;Installing Docker in Windows&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;linux-installation&#34;&gt;Linux Installation&lt;/h2&gt;

&lt;p&gt;Installing Docker in Linux depends of every distribution &lt;a href=&#34;https://docs.docker.com/engine/installation/linux/&#34;&gt;check here&lt;/a&gt; the details.&lt;/p&gt;

&lt;p&gt;Docker Engine is supported on several Linux distributions. Installation instructions are available for the following:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.docker.com/engine/installation/linux/archlinux/&#34;&gt;Arch Linux&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.docker.com/engine/installation/linux/centos/&#34;&gt;CentOS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.docker.com/engine/installation/linux/cruxlinux/&#34;&gt;CRUX Linux&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.docker.com/engine/installation/linux/debian/&#34;&gt;Debian&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.docker.com/engine/installation/linux/fedora/&#34;&gt;Fedora&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.docker.com/engine/installation/linux/frugalware/&#34;&gt;FrugalWare&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.docker.com/engine/installation/linux/gentoolinux/&#34;&gt;Gentoo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.docker.com/engine/installation/linux/oracle/&#34;&gt;Oracle Linux&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.docker.com/engine/installation/linux/rhel/&#34;&gt;Red Hat Enterprise Linux&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.docker.com/engine/installation/linux/SUSE/&#34;&gt;openSUSE and SUSE Linux Enterprise&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.docker.com/engine/installation/linux/ubuntulinux/&#34;&gt;Ubuntu&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If your linux distribution is not listed above, don’t give up yet.
To try out Docker on a distribution that is not listed above, go here: &lt;a href=&#34;https://docs.docker.com/engine/installation/binaries/&#34;&gt;Installation from binaries&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>BioDocker History</title>
      <link>http://biodocker.org/docs/biodocker-history/</link>
      <pubDate>Fri, 03 Jun 2016 21:48:35 +0100</pubDate>
      
      <guid>http://biodocker.org/docs/biodocker-history/</guid>
      <description>

&lt;h1 id=&#34;biodocker-history&#34;&gt;BioDocker History&lt;/h1&gt;

&lt;p&gt;In 2012, Felipe Leprevost and Yasset Perez-Riverol started a formal an strong collaboration when both of them were doing the PhD in Brazil
and Cuba, respectively.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;../../icons/felipe-yasset.jpg&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;In 2014, they published a first manuscript of best practices to for bioinformatics software development:
&lt;a href=&#34;http://journal.frontiersin.org/article/10.3389/fgene.2014.00199&#34;&gt;On best practices in the development of bioinformatics software&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In 2013, &lt;a href=&#34;https://en.wikipedia.org/wiki/Docker_(software)&#34;&gt;Docker&lt;/a&gt; became a more stable framework and rapidly grows in the IT community,
amount developers, software engenders, etc. In 2015, we started BioDocker as a community-driven project to standardize the way we
develop, deploy and use bioinformatics software.&lt;/p&gt;

&lt;p&gt;In 2015, two new developers become members of the project &lt;a href=&#34;https://github.com/sauloal&#34;&gt;Saulo Alves&lt;/a&gt; and
&lt;a href=&#34;https://github.com/bgruening&#34;&gt;Björn Grüning&lt;/a&gt; (from Galaxy Team) moving forward the project into a community-driven
initiative.&lt;/p&gt;

&lt;p&gt;BioDocker has received an special attention from Mass-Spectrometry and Proteomics
community. At the moment of writing (June 2016) BioDocker Provides more
than &lt;a href=&#34;https://github.com/BioDocker/containers&#34;&gt;20 ready to use containers&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Some of the major contributors to the project:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Felipe da Veiga Leprevost (Departments of Pathology and Computational Medicine and Bioinformatics, University of Michigan, Ann Arbor, Michigan 48109.)&lt;/li&gt;
&lt;li&gt;Yasset Perez-Riverol (EMBL-EBI, Wellcome Trust Genome Campus, Hinxton, Cambridge, U.K)&lt;/li&gt;
&lt;li&gt;Saulo Alves Aflitos (Applied Bioinformatics, Wageningen University, Wageningen, The Netherlands)&lt;/li&gt;
&lt;li&gt;Björn A. Grüning (Bioinformatics Group, Department of Computer Science, Albert-Ludwigs-University Freiburg, Freiburg, Germany)&lt;/li&gt;
&lt;li&gt;Laurent Gatto (Computational Proteomics Unit and Cambridge Centre for Proteomics, Department of Biochemistry, University of Cambridge, Cambridge, UK)&lt;/li&gt;
&lt;li&gt;Hannes L. Röst (Department of Genetics, Stanford University, USA)&lt;/li&gt;
&lt;li&gt;Julian Uszkoreit (Medizinisches Proteom-Center, Ruhr-Universität Bochum Bochum, Germany)&lt;/li&gt;
&lt;li&gt;Harald Barsnes (Proteomics Unit (PROBE), Department of Biomedicine, University of Bergen, Bergen, Norway)&lt;/li&gt;
&lt;li&gt;Marc Vaudel (Proteomics Unit (PROBE), Department of Biomedicine, University of Bergen, Bergen, Norway)&lt;/li&gt;
&lt;li&gt;Timo Sachsenberg (Center for Bioinformatics, University of Tübingen, Tübingen, Germany)&lt;/li&gt;
&lt;li&gt;Julianus Pfeuffer (Algorithmic bioinformatics group, Freie Universität Berlin, Berlin, Germany)&lt;/li&gt;
&lt;li&gt;Rafael Jimenez (EMBL-EBI, Wellcome Trust Genome Campus, Hinxton, Cambridge, U.K)&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>